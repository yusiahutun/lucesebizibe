<!doctype html><html lang=en><head><meta charset=utf-8><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=referrer content="no-referrer"><meta name=description content="I need to do a histogram equalization for a colored image. First I convert the colored image to gray and give it to the equalizeHist function: But after this I need to convert the image back to RGB; how can i do that?"><meta name=robots content="index,follow,noarchive"><link href="https://fonts.googleapis.com/css?family=Open+Sans:400|Old+Standard+TT:400&display=swap" rel=stylesheet media=print type=text/css onload='this.media="all"'><title>OpenCV Python equalizeHist colored image</title><link rel=canonical href=./opencv-python-equalizehist-colored-image.html><style>*{border:0;font:inherit;font-size:100%;vertical-align:baseline;margin:0;padding:0;color:#000;text-decoration-skip:ink}body{font-family:open sans,myriad pro,Myriad,sans-serif;font-size:17px;line-height:160%;color:#1d1313;max-width:700px;margin:auto}p{margin:20px 0}a img{border:none}img{margin:10px auto;max-width:100%;display:block}.left-justify{float:left}.right-justify{float:right}pre,code{font:12px Consolas,liberation mono,Menlo,Courier,monospace;background-color:#f7f7f7}code{font-size:12px;padding:4px}pre{margin-top:0;margin-bottom:16px;word-wrap:normal;padding:16px;overflow:auto;font-size:85%;line-height:1.45}pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:0 0;border:0}pre code{display:inline;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}pre code::before,pre code::after{content:normal}em,q,em,dfn{font-style:italic}.sans,html .gist .gist-file .gist-meta{font-family:open sans,myriad pro,Myriad,sans-serif}.mono,pre,code,tt,p code,li code{font-family:Menlo,Monaco,andale mono,lucida console,courier new,monospace}.heading,.serif,h1,h2,h3{font-family:old standard tt,serif}strong{font-weight:600}q:before{content:"\201C"}q:after{content:"\201D"}del,s{text-decoration:line-through}blockquote{font-family:old standard tt,serif;text-align:center;padding:50px}blockquote p{display:inline-block;font-style:italic}blockquote:before,blockquote:after{font-family:old standard tt,serif;content:'\201C';font-size:35px;color:#403c3b}blockquote:after{content:'\201D'}hr{width:40%;height:1px;background:#403c3b;margin:25px auto}h1{font-size:35px}h2{font-size:28px}h3{font-size:22px;margin-top:18px}h1 a,h2 a,h3 a{text-decoration:none}h1,h2{margin-top:28px}#sub-header,.date{color:#403c3b;font-size:13px}#sub-header{margin:0 4px}#nav h1 a{font-size:35px;color:#1d1313;line-height:120%}.posts_listing a,#nav a{text-decoration:none}li{margin-left:20px}ul li{margin-left:5px}ul li{list-style-type:none}ul li:before{content:"\00BB \0020"}#nav ul li:before,.posts_listing li:before{content:'';margin-right:0}#content{text-align:left;width:100%;font-size:15px;padding:60px 0 80px}#content h1,#content h2{margin-bottom:5px}#content h2{font-size:25px}#content .entry-content{margin-top:15px}#content .date{margin-left:3px}#content h1{font-size:30px}.highlight{margin:10px 0}.posts_listing{margin:0 0 50px}.posts_listing li{margin:0 0 25px 15px}.posts_listing li a:hover,#nav a:hover{text-decoration:underline}#nav{text-align:center;position:static;margin-top:60px}#nav ul{display:table;margin:8px auto 0}#nav li{list-style-type:none;display:table-cell;font-size:15px;padding:0 20px}#links{display:flex;justify-content:space-between;margin:50px 0 0}#links :nth-child(1){margin-right:.5em}#links :nth-child(2){margin-left:.5em}#not-found{text-align:center}#not-found a{font-family:old standard tt,serif;font-size:200px;text-decoration:none;display:inline-block;padding-top:225px}@media(max-width:750px){body{padding-left:20px;padding-right:20px}#nav h1 a{font-size:28px}#nav li{font-size:13px;padding:0 15px}#content{margin-top:0;padding-top:50px;font-size:14px}#content h1{font-size:25px}#content h2{font-size:22px}.posts_listing li div{font-size:12px}}@media(max-width:400px){body{padding-left:20px;padding-right:20px}#nav h1 a{font-size:22px}#nav li{font-size:12px;padding:0 10px}#content{margin-top:0;padding-top:20px;font-size:12px}#content h1{font-size:20px}#content h2{font-size:18px}.posts_listing li div{font-size:12px}}@media(prefers-color-scheme:dark){*,#nav h1 a{color:#fdfdfd}body{background:#121212}pre,code{background-color:#262626}#sub-header,.date{color:#bababa}hr{background:#ebebeb}}</style></head><body><section id=nav><h1><a href=./index.html>BlinkVlog</a></h1><ul><li><a href=./index.xml>Rss</a></li><li><a href=./sitemap.xml>Sitemap</a></li></ul></section><section id=content><h1>OpenCV Python equalizeHist colored image</h1><div id=sub-header>June 2024 · 6 minute read</div><div class=entry-content><p>I need to do a histogram equalization for a colored image.</p><p>First I convert the colored image to gray and give it to the <code>equalizeHist</code> function:</p><pre><code>image = cv2.imread("photo.jpg") image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) cv2.equalizeHist(image) cv2.imshow("equalizeHist", image) cv2.waitKey(0) </code></pre><p>But after this I need to convert the image back to RGB; how can i do that?</p><span class=d-none itemprop=commentCount>0</span><h2 class=mb0 data-answercount=11>11 Answers</h2><p>Source : <a href=# rel=noreferrer>https://www.packtpub.com/packtlib/book/Application-Development/9781785283932/2/ch02lvl1sec26/Enhancing%20the%20contrast%20in%20an%20image</a></p><pre><code>import cv2 import numpy as np img = cv2.imread('input.jpg') img_yuv = cv2.cvtColor(img, cv2.COLOR_BGR2YUV) # equalize the histogram of the Y channel img_yuv[:,:,0] = cv2.equalizeHist(img_yuv[:,:,0]) # convert the YUV image back to RGB format img_output = cv2.cvtColor(img_yuv, cv2.COLOR_YUV2BGR) cv2.imshow('Color input image', img) cv2.imshow('Histogram equalized', img_output) cv2.waitKey(0) </code></pre><p>~edit: original link is no longer available, similar idea is implemented here: <a href=# rel=noreferrer>Histogram Equalization of a Color image with OpenCV</a></p><span class=d-none itemprop=commentCount>4</span><p><a href=# rel=noreferrer><img src=https://cdn.statically.io/img/i.stack.imgur.com/UCYQs.png alt="input image vs. equalized image" style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><h2>Python Code</h2><pre><code>import cv2 def run_histogram_equalization(image_path): rgb_img = cv2.imread(image_path) # convert from RGB color-space to YCrCb ycrcb_img = cv2.cvtColor(rgb_img, cv2.COLOR_BGR2YCrCb) # equalize the histogram of the Y channel ycrcb_img[:, :, 0] = cv2.equalizeHist(ycrcb_img[:, :, 0]) # convert back to RGB color-space from YCrCb equalized_img = cv2.cvtColor(ycrcb_img, cv2.COLOR_YCrCb2BGR) cv2.imshow('equalized_img', equalized_img) cv2.waitKey(0) </code></pre><h2>Explanation</h2><p>Histogram Equalization (HE) is a statistical approach for spreading out intensity values. In image processing, HE is used for improving the contrast of any image, that is- to make the dark portion darker and the bright portion brighter.</p><p>For a grey-scale image, each pixel is represented by the intensity value (brightness); that is why we can feed the pixel values directly to the HE function. However, that is not how it works for an RGB-formatted color image. Each channel of the R, G, and B represents the intensity of the related color, not the intensity/brightness of the image as a whole. And so, <strong>running HE on these color channels is NOT the proper way</strong>.</p><p>We should first separate the brightness of the image from the color and then run HE on the brightness. Now, there are already standardized colorspaces that encode brightness and color separately, like- YCbCr, HSV, etc.; so, we can use them here for separating and then re-merging the brightness. The proper way:</p><p><b>Convert the colorspace from RGB to YCbCr >> Run HE on the Y channel (this channel represents brightness) >> Convert back the colorspace to RGB</b></p><h2>Postscript</h2><p>For HSV colorspace, HE should be run on the V channel. However, the Y channel of YCbCr is the better representer for brightness than the V channel of HSV. So, <strong>using the YCbCr format produces a more correct result for HE</strong>.</p><p><a href=# rel=noreferrer><img src=https://cdn.statically.io/img/i.stack.imgur.com/JVagx.png alt="HSV vs YCbCr" style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><h2>Postscript 2</h2><p>HE is too a naive technique and often produces peculiar colors and small artifacts. This is because it does not care about outliers and the location of a pixel. So, extensions like- ‎Contrast Limited Adaptive HE, Brightness preserving Bi-HE, etc. are used more commonly. Also, different noise reduction functions are executed in the post-processing phase for improving the final output.</p><span class=d-none itemprop=commentCount></span><p>A more general approach would be transforming RGB values into another space that contains a luminescence/intensity value (Luv, Lab, HSV, HSL), apply histeq only in intensity plane and perform the inverse transform.</p><span class=d-none itemprop=commentCount></span><p>You do not have to first convert your image to grayscale. You can use the approach below. A suggested solution above used the YUV colour space but I will do this example using the HSV colour space.</p><pre><code>image = cv2.imread("photo.jpg") # convert image from RGB to HSV img_hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV) # Histogram equalisation on the V-channel img_hsv[:, :, 2] = cv2.equalizeHist(img_hsv[:, :, 2]) # convert image back from HSV to RGB image = cv2.cvtColor(img_hsv, cv2.COLOR_HSV2RGB) cv2.imshow("equalizeHist", image) cv2.waitKey(0) </code></pre><span class=d-none itemprop=commentCount>3</span><pre><code>img_yuv = cv2.cvtColor(image, cv2.COLOR_BGR2YUV) clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(2,2)) img_yuv[:,:,0] = clahe.apply(img_yuv[:,:,0]) img = cv2.cvtColor(img_yuv, cv2.COLOR_YUV2BGR) cv2.imshow("equalizeHist", img) cv2.waitKey(0) </code></pre><span class=d-none itemprop=commentCount>4</span><p>The color conversion method cv2.cvtColor() is used to convert the original image in between RGB/BGR and YUV. Here is the best coding snippet -</p><pre><code># convert it to grayscale img_yuv = cv2.cvtColor(img,cv2.COLOR_BGR2YUV) # apply histogram equalization img_yuv[:,:,0] = cv2.equalizeHist(img_yuv[:,:,0]) hist_eq = cv2.cvtColor(img_yuv, cv2.COLOR_YUV2BGR) </code></pre><p>You can know more on this from here - <a href=# rel="nofollow noreferrer">https://www.etutorialspoint.com/index.php/311-python-opencv-histogram-equalization</a></p><span class=d-none itemprop=commentCount></span><p>Here is a function which would take color image as input and will return the histogram equalize image.</p><pre><code># function for color image equalization def histogram_equalization(img_in): # segregate color streams b, g, r = cv2.split(img_in) h_b, bin_b = np.histogram(b.flatten(), 256, [0, 256]) h_g, bin_g = np.histogram(g.flatten(), 256, [0, 256]) h_r, bin_r = np.histogram(r.flatten(), 256, [0, 256]) # calculate cdf cdf_b = np.cumsum(h_b) cdf_g = np.cumsum(h_g) cdf_r = np.cumsum(h_r) # mask all pixels with value=0 and replace it with mean of the pixel values cdf_m_b = np.ma.masked_equal(cdf_b, 0) cdf_m_b = (cdf_m_b - cdf_m_b.min()) * 255 / (cdf_m_b.max() - cdf_m_b.min()) cdf_final_b = np.ma.filled(cdf_m_b, 0).astype('uint8') cdf_m_g = np.ma.masked_equal(cdf_g, 0) cdf_m_g = (cdf_m_g - cdf_m_g.min()) * 255 / (cdf_m_g.max() - cdf_m_g.min()) cdf_final_g = np.ma.filled(cdf_m_g, 0).astype('uint8') cdf_m_r = np.ma.masked_equal(cdf_r, 0) cdf_m_r = (cdf_m_r - cdf_m_r.min()) * 255 / (cdf_m_r.max() - cdf_m_r.min()) cdf_final_r = np.ma.filled(cdf_m_r, 0).astype('uint8') # merge the images in the three channels img_b = cdf_final_b[b] img_g = cdf_final_g[g] img_r = cdf_final_r[r] img_out = cv2.merge((img_b, img_g, img_r)) # validation equ_b = cv2.equalizeHist(b) equ_g = cv2.equalizeHist(g) equ_r = cv2.equalizeHist(r) equ = cv2.merge((equ_b, equ_g, equ_r)) # print(equ) # cv2.imwrite('output_name.png', equ) return img_out </code></pre><span class=d-none itemprop=commentCount></span><p>i'm not sure that it works properly :</p><pre><code>def histogram_equalize(img): b, g, r = cv2.split(img) red = cv2.equalizeHist(r) green = cv2.equalizeHist(g) blue = cv2.equalizeHist(b) return cv2.merge((blue, green, red)) </code></pre><span class=d-none itemprop=commentCount>2</span><p>If u want to equalizeHist the RGB image, u should not convert to gray instead of equalize RGB channels one by one.</p><p>So, i think maybe here is what u want:</p><pre><code>def equalize_hist(img): for c in xrange(0, 2): img[:,:,c] = cv2.equalizeHist(img[:,:,c]) cv2.imshow('Histogram equalized', img) cv2.waitKey(0) return img </code></pre><span class=d-none itemprop=commentCount>2</span><p>you should not convert the image in to gray scale. you can do it with the colored image. but always OpenCV read the image with BGR color format. not in RGB format</p><pre><code>import cv2 # imread needs 2 parameters. path and the flag img = cv2.imread("photo.jpg", 1) # convert image from BGR to HSV img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV) # Histogram equalisation on the V-channel img_hsv[:, :, 2] = cv2.equalizeHist(img_hsv[:, :, 2]) # now the img_hsv has equalized # now convert hsv image back from HSV to RGB imgequalized = cv2.cvtColor(img_hsv, cv2.COLOR_HSV2RGB) cv2.imshow("original img", img) cv2.imshow("equalizeHist", imgequalized) cv2.waitKey(0) </code></pre><span class=d-none itemprop=commentCount></span><p>The code above renders the use of histogram equalization in different color spaces.</p><pre class="lang-py prettyprint-override"><code>import cv2 import matplotlib.pyplot as plt import math img = cv2.imread('../pix/Lenna.png') def contrast(img, color_space, channels): img_temp = img if color_space == 'BGR' else cv2.cvtColor(img, eval(f"cv2.COLOR_BGR2{color_space}")) img_temp = cv2.merge([cv2.equalizeHist(c) if i in channels else c for i, c in enumerate(cv2.split(img_temp))]) return img_temp if color_space == 'RGB' else cv2.cvtColor(img_temp, eval(f"cv2.COLOR_{color_space}2RGB")) # a dictionary with the names of the color spaces to which the image needs to be converted and the channel numbers to be converted spaces = {'BGR': [], 'GRAY': [0], 'RGB': [0, 1, 2], 'HSV': [2], 'HLS': [1], 'YCrCb': [0], 'Lab': [0], 'Luv': [0], 'YUV': [0]} fig = plt.figure(figsize = (15, 15)) cols = 3 rows = math.ceil(len(spaces) / cols) for i, s in enumerate(spaces): fig.add_subplot(rows, cols, i+1) plt.imshow(contrast(img, s, spaces[s])); # what color space has been converted to and what channel numbers have been changed plt.title(f"BGR → {s} {spaces[s]} → RGB") plt.show() </code></pre><p><a href=# rel="nofollow noreferrer"><img src=https://cdn.statically.io/img/i.stack.imgur.com/B0Gvh.jpg alt="Applying equalizeHist across different color spaces" style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><span class=d-none itemprop=commentCount></span><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmirpJawrLvVnqmfpJ%2Bse6S7zGiorp2jqbawutJoampxaW2Bc4SOqKeeppOrerHF06Gmp2WVpsKiuMiznKGho6l6pLvLqKmenF2euqKzxA%3D%3D</p></div><div id=links><a href=./aaron-diaz.html>&#171;&nbsp;Who is Aarn Daz dating? Aarn Daz girlfriend, wife</a>
<a href=./lets-stop-sexualising-image-women-flight-attendants.html>Let's stop sexualising the image of women flight attendants&nbsp;&#187;</a></div></section><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/floating.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>